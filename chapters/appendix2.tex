% !TeX root = ../Thesis.tex

In some cases, opening a variable can be postponed in order to avoid the  storage of the information about runs that will not result in an output. To illustrate this, consider the expression
\begin{center}
	\texttt{!x\{sparql[\textasciicircum \textbackslash n]*\}\textbackslash n}
\end{center}
which looks for the keyword \texttt{sparql}, and then proceeds to capture the text until the first end of line symbol is reached. In a log file, such as the ones studied in \cite{AMRV16}, this roughly corresponds to capturing a SPARQL query. Notice that here Algorithm \ref{alg:evaluation} would store the position information for the opening of a variable \texttt{x} every time an \texttt{s} would be read. If the document we are reading has the text \texttt{sparx}, this run would then be extended for three more steps, although it will eventually be abandoned, and not result in any outputs. Given the node management required when changing the state of the ECS structure, this can bring a significant overhead to evaluation. In cases such as these, we can actually postpone (i.e. offset) the opening of the variable \texttt{x}. by proceeding as follows: (i) first read the word \texttt{sparql}; (ii) now open a variable \texttt{x}, but remember that it was actually opened six symbols before (i.e. it has an offset 6); (iii) proceed until the end of the expression. Then, when reconstructing the output in case of a successful run, we will simply start reading the output six symbols before the position that is actually stored in \texttt{ds} from Algorithm \ref{alg:evaluation}. Intuitively, one could write the expression above as:
\begin{center}
	\texttt{sparql!x\{$^{-6}$[\textasciicircum \textbackslash n]*\} \textbackslash n} 
\end{center}
In order to signal that when opened, the variable \texttt{x} actually stores characters starting six positions before the guarded position.

\subsection{Offset logical VA} 
To formalize this concept we extend the definition of a logical VA as follows: a \emph{logical variable-set automata} (offset logical VA) $\cAoff$ is a tuple $(Q, \delta, \tau, q_0, q_f)$ that has the same structure as a logical VA, with the addition of an \emph{offset marker} function $\tau$ that takes a variable marker as input and returns an integer.

A configuration, a run and an accepting run of $\cAoff$ are defined exactly as if $\cAoff$ were a logical VA. The only change is in the definition of its semantics. Suppose that 
$$
	\rho \ = \ (q_0, i_0) \ \trans{o_1} \ (q_1, i_1) \ \trans{o_2} \ \cdots \ \trans{o_m} \ (q_m, i_m)
$$
is an accepting run of $\cAoff$. The mapping $\mu^\rho$ then is such that it maps $x$ to $[i_j, i_k\rangle$ if, and only if, $o_{i_j + \tau([x)} = [x$ and $o_{i_k + \tau(x\rangle)} = x\rangle$. In other words, the mapping $\mu^\rho$ acts in the same way as if $\cAoff$ were a logical VA, but taking into account the offsets given by $\tau$ for each of the variable markers present in the transitions of $\cAoff$. Therefore, the semantics of $\sem{\cAoff}_d$ of $\cAoff$ over a document $d$ is defined as the set of all $\mu^\rho$ where $\rho$ is an accepting run of $\cAoff$ over $d$.

Given the way Algorithm \ref*{alg:evaluation} works. It is desirable to be able to construct an offset logical VA $\cAoff$ from an initial logical VA $\cA$ such that: (i) the semantics are preserved, i.e. $\sem{\cAoff}_d = \sem{\cA}_d$ and (ii) the offset function $\tau$ of $\cAoff$ is optimal in a way to maximize the offsets for the variable markers, so that the decision of changing the state of the ECS is postponed while reading the document. In REmatch, this is done by the following algorithm, which we call \texttt{offset}.

\subsection{Offset algorithm}
In the implementation of REmatch, the \texttt{offset} optimization is done in the early stages of preprocessing the query. After the first parse of the expression, REmatch will build a eVA as described in \cite{FlorenzanoRUVV20}, namely each transition either opening or closing a single variable (referred to as a capture transition), or processing a symbol (called a reading transition). We also assume no  $\varepsilon$ transitions to be present in the automaton.

First, for each variable opening we build a list of all the transitions that open this variable, and we do the same for each variable closing. The variable opening/closing is then offset in bulk, namely, either all of the transitions of the form $\Open{x}$ (or $\Close{x}$) are moved at once (in order to preserve consistency), or none is. Let \texttt{captureList} be a list of all capture transitions opening or closing some variable (for instance, they are all of the form $\Open{x}$). For a capture transition $p\ \longtrans{\Open{x}}\ q$ we wish to see if there is also a transition $q\ \longtrans{a}\ r$, in order to interchange the transition reading the letter $a$, and the one opening the variable $x$. That is, we wish to achieve the following transformation in the states of our eVA:
$$p\ \longtrans{\Open{x}}\ q\ \longtrans{a}\ r \ \ \ \ \ \Rightarrow \ \ \ \ \ \ \ p\ \longtrans{a}\ q\ \longtrans{\Open{x}}\ r$$


We will say that we can offset $\Open{x}$ if the following conditions hold for every transition $p\ \longtrans{\Open{x}}\ q$ appearing in \texttt{captureList} associated with $\Open{x}$:
\begin{enumerate}
	\item $q$ is not a final state;
	\item There are no transition of the form $q\ \longtrans{\Open{y}}\ r$, or of the form $p'\ \longtrans{v}\ q$, with $v$ a variable marker, in the automaton;
	\item There is at least one transition of the form $q\ \longtrans{a}\ r$;
	\item For all transitions $q\ \longtrans{a}\ r$, $q$ can not be reachable from $r$; and
	\item For any other transition $p'\ \longtrans{\Open{x}}\ q'$, if we take any $q\ \longtrans{a}\ r$, then $q'$ is not reachable from $r$.
\end{enumerate}

The first condition prevents offsetting a variable that leads to an accepting run. The second condition prevents manipulating a state which has multiple capture transitions associated with it. The third condition assures we actually have a transition to offset. Fourth transition makes sure that in case of moving the $\Open{x}$ variable marker forward, we will not create any loops involving this variable marker. Finally, the last condition ensures that moving one $\Open{x}$ variable marker will not result in an inconsistent run involving another such transition. This could, for instance, happen if we had both $p\ \longtrans{\Open{x}}\ q\ \longtrans{a}\ r$ and $p'\ \longtrans{\Open{x}}\ q'\ \longtrans{a}\ q$ in our automaton, since offsetting the first $\Open{x}$ transition would result in an automaton that has a run opening $x$ twice.

Given each such list \texttt{captureList} (for example for $\Open{x}$), we manipulate each set of transitions $p\ \longtrans{\Open{x}}\ q\ \longtrans{a}\ r$, by switching the $\Open{x}$ and $a$ symbols (in reality, an auxiliary state is created for this). The new \texttt{captureList} is then populated by adding the transitions $q\ \longtrans{\Open{x}}\ r$ to it, and the process is repeated as long as the newly created list satisfies the five conditions specified above.

Finally, we process the variable offsets by finding the reverse topological order of all the capture transitions.
Then we offset the variables in this order so that we can move them as far forward as possible. To illustrate why this is important, consider the automaton consisting of a single run as follows:
$$q_0\ \longtrans{\Open{x}}\ q_1\ \longtrans{a}\ q_2\ \longtrans{\Close{x}}\ q_3\ \longtrans{b}\ q4$$
If we were to first offset the $\Open{x}$ variable marker, this would result in:
$$q_0\ \longtrans{a}\ q_1\ \longtrans{\Open{x}^{-1}}\ q_2\ \longtrans{\Close{x}}\ q_3\ \longtrans{b}\ q4$$
and $\Close{x}$ could not be offset due to condition (2) above. On the other hand, processing the variables in reverse topological order results in:
$$q_0\ \longtrans{a}\ q_1\ \longtrans{b}\ q_2\ \longtrans{\Open{x}^{-2}}\ q_3\ \longtrans{\Close{x}^{-1}}\ q4$$.