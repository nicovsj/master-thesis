% % !TeX root = ../main.tex

Regular expressions, or RegEx, are one of the most used technologies for managing text data. The development of RegEx engines started in the early 70s~\cite{thompson1968programming,earlyNFA}, and they are now a common part of many complex information systems such as compilers, databases, or search engines. Moreover, modern RegEx engines are highly-optimized systems that are crucial for finding patterns in diverse areas like biology~\cite{Gonzalo}, literature~\cite{lit1}, or medicine~\cite{FloresFP21}. 


Given a regular expression and a document, the task of a RegEx engine is to find all occurrences, or \emph{matches}, of the pattern in the document. For this, RegEx engines deploy the so-called \emph{leftmost-longest} paradigm~\cite{posix}, meaning that they find the match which is the leftmost one, and from there they find the longest possible match. The process is then repeated  starting from the rightmost position of the previous match\footnote{Although RegEx engines follow different matching rules, the leftmost-longest rule is at the core of most modern engines. For a detailed discussion see \cite{friedl2006mastering}.}. For example, if we want to evaluate the RegEx $\texttt{aa}$ over the document $a_0 a_1 a_2 a_3$ (here the subindices are for referencing positions; the document consists of the letter $a$ repeated four times), a typical RegEx engine will output the matches $a_0a_1$ and $a_2a_3$. In particular, RegEx engines will not output $a_1a_2$ since the first leftmost-longest match ends with $a_1$. 

The leftmost-longest semantics is standard for  RegEx engines, as it captures the majority of meaningful matches, although not all of them. However, in some scenarios adopting an ``all-match semantics'' is a valuable and desirable feature for the users. For instance, in DNA analysis we will often need to match patterns (called motifs) onto a DNA sequence, and these can overlap. The question of finding overlapping matches with RegEx is also recurrent in user discussions~\cite{overlap1,overlap2,overlap3}. For information extraction, the all-match semantics leaves freedom to the user to extract all positions, called spans, where there is relevant information in a document. Therefore the all-match semantics is a desirable feature for RegEx engines that, to the best of our knowledge, no engine supports natively.

To overcome the problem of finding all-matches, RegEx engines offer look-around operators, namely, operators that allows checking if a subexpression can be matched forward or backward from the current position, without advancing from the current position. For instance, by using look-around, we can modify the expression \texttt{aa} to \texttt{(?=(aa))} and find the missing match $a_1a_2$ over the above document. Despite this example, look-around operators cannot discover all matches for every RegEx expression. For instance, given the look-around definition, one cannot extract two matches that start at the same position (for concrete examples see Section~\ref{chpt:regex} and Section~\ref{sec:experiments}).

In terms of implementation, RegEx engines are usually divided into three categories: DFA-based, NFA-based, and recursive NFA-based~\cite{cox2007regular}. DFA is generally the fastest evaluation strategy, followed by (plain) NFA. In contrast, recursive NFA-based engines use backtracking, which is susceptible to well-documented performance issues, like regular expression denial of service attacks (ReDos)~\cite{friedl2006mastering}, where the engine can exhibit exponential time performance~\cite{cox2007regular}. From the positive side, recursive NFA-based engines have the advantage of keeping track of the evaluation, which allows implementing operators like look-around and back-references.
In summary, until now, the only way of finding all matches (in some cases) is by using look-around operators implemented by recursive NFA-based engines, which suffer from unfortunate performance issues. 

To overcome these issues, this thesis presents \rematch, a RegEx engine supporting the all-match semantics, and its accompanying regular expression language REQL. Contrary to the status quo of RegEx evaluation, \rematch\ is based on a new evaluation strategy, inspired by the theory of enumeration algorithms~\cite{Segoufin13}, that allows finding all the matches, and avoids the exponential behavior of recursive NFA evaluation. Moreover, \rematch\ performance is comparable to popular RegEx engines, while at the same time finding all the matches, thus obtaining the best of both worlds. Specific contributions of the thesis are as follows:

\begin{enumerate}

\item  We introduce the REQL query language, which extends classical RegEx with variables and the all-match semantics.	

\item We present \rematch, a RegEx system whose architecture allows evaluating REQL using output-linear delay. For this, we develop a new evaluation method which extends the theoretical algorithm of~\cite{FlorenzanoRUVV20} and incorporates new optimization techniques, allowing \rematch\ to compete with modern RegEx engines. 

\item We develop a set of experiments to evaluate the effect of different optimizations on \rematch\ performance, and compare it to existing RegEx engines. Although \rematch\ uses a more general semantics, we show that its performance stacks well compared to other engines.
	
\end{enumerate}

In Section~\ref{chpt:regex} we introduce REQL. We then explain each module of the \rematch\ architecture (see~Figure~\ref{fig:architecture}). Section~\ref{sec:rewriting} presents the rewriting module, Section~\ref{sec:filtering} the filtering module, and Section~\ref{sec:output} the output module. Section~\ref{sec:evaluation} explains the evaluation algorithm of \rematch. Section~\ref{sec:experiments} puts all components together and displays the experimental comparison with other engines. We conclude in Section~\ref{sec:conclusions} by discussing possible future work. 